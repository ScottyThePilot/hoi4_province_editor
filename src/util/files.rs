use ahash::AHashMap;
use fs_err::{File, OpenOptions};
use defy::{ContextualError, Contextualize};
use thiserror::Error;
use unicase::UniCase;
use unicase::bytemuck::TransparentWrapper;
use zip::read::ZipArchive;
use zip::write::ZipWriter;

use crate::error::Error;

use std::io::{self, prelude::*};
use std::ops::{Deref, DerefMut};
use std::path::{Path, PathBuf};
use std::fmt;



fn reject_err<T, E>(result: Result<T, E>, predicate: impl FnOnce(&E) -> bool) -> Result<Option<T>, E> {
  match result {
    Ok(value) => Ok(Some(value)),
    Err(err) if predicate(&err) => Ok(None),
    Err(err) => Err(err)
  }
}



#[derive(Debug, Error)]
pub enum FilesError {
  #[error("io error: {0}")]
  Io(#[from] ContextualError<io::Error>),
  #[error("zip error: {0}")]
  Zip(#[from] ContextualError<zip::result::ZipError>),
  #[error(transparent)]
  Location(#[from] IntoLocationError),
  #[error("file could not be found: {}", .0.display())]
  FilesMapFileNotFound(PathBuf),
  #[error("file already exists: {}", .0.display())]
  FilesMapFileAlreadyExists(PathBuf)
}

impl FilesError {
  /// Convert `Result<T, Self>` to `Result<Option<T>, Self>` when `Self` is `Io` and is of the specified [`io::ErrorKind`] (`Err(Self)` becomes `Ok(None)` in this case).
  pub fn reject_io_err<T>(result: Result<T, Self>, io_error_kind: io::ErrorKind) -> Result<Option<T>, Self> {
    reject_err(result, |err| matches!(err, Self::Io(ContextualError { error, .. }) if error.kind() == io_error_kind))
  }
}



pub fn is_zip_file(path: &Path) -> bool {
  path.extension().is_some_and(|extension| {
    extension.eq_ignore_ascii_case("zip")
  })
}

pub fn is_core_file(path: &Path) -> bool {
  path.file_name().is_some_and(|file_name| {
    file_name.eq_ignore_ascii_case("provinces.bmp") ||
    file_name.eq_ignore_ascii_case("definition.csv")
  })
}



#[derive(Debug, Clone)]
pub enum Location {
  ZipArchive(PathBuf),
  Directory(PathBuf)
}

impl Location {
  pub fn as_path(&self) -> &Path {
    match self {
      Location::ZipArchive(path) => path,
      Location::Directory(path) => path
    }
  }

  pub fn into_pathbuf(self) -> PathBuf {
    match self {
      Location::ZipArchive(path) => path,
      Location::Directory(path) => path
    }
  }

  fn from_path(path: impl Into<PathBuf>) -> Result<Self, IntoLocationError> {
    let mut path = path.into();
    let metadata = path.metadata().context("failed to read metadata")?;

    if metadata.is_file() {
      if is_zip_file(&path) {
        return Ok(Location::ZipArchive(path));
      };

      if is_core_file(&path) {
        path.pop();
        return Ok(Location::Directory(path));
      };
    };

    if metadata.is_dir() {
      return Ok(Location::Directory(path));
    };

    Err(IntoLocationError::Invalid(path))
  }

  pub fn manipulate_files<R>(self, operation: impl FnOnce(&mut FilesAbstraction) -> Result<R, Error>) -> Result<R, Error> {
    let mut files = FilesAbstraction::new(self)?;
    let result = operation(&mut files)?;
    files.dispose()?;
    Ok(result)
  }
}

impl fmt::Display for Location {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match self {
      Location::ZipArchive(path) => write!(f, "zip archive {}", path.display()),
      Location::Directory(path) => write!(f, "directory {}", path.display())
    }
  }
}

pub trait IntoLocation {
  fn into_location(self) -> Result<Location, FilesError>;
}

impl IntoLocation for Location {
  fn into_location(self) -> Result<Location, FilesError> {
    Ok(self)
  }
}

impl<T> IntoLocation for T where T: Into<PathBuf> {
  fn into_location(self) -> Result<Location, FilesError> {
    Location::from_path(self).map_err(FilesError::from)
  }
}

#[derive(Debug, Error)]
pub enum IntoLocationError {
  #[error("cannot extract location: {0}")]
  Io(#[from] ContextualError<io::Error>),
  #[error("cannot extract location from path {}: not a valid location", .0.display())]
  Invalid(PathBuf)
}



pub type FileHandleDyn<'h> = Box<dyn FileHandle + 'h>;

pub trait FileHandle: Read + Write + Seek {}

impl<T> FileHandle for T where T: Read + Write + Seek {}

#[derive(Debug)]
pub enum FilesAbstraction {
  Directory {
    root: PathBuf
  },
  ZipArchive {
    file: File,
    zip: ZipArchiveFilesMap
  }
}

impl FilesAbstraction {
  pub fn new(location: impl IntoLocation) -> Result<Self, FilesError> where Self: Sized {
    match location.into_location()? {
      Location::Directory(root) => {
        let root = canonicalize(root)?;
        Ok(Self::Directory { root })
      },
      Location::ZipArchive(path) => {
        let (file, mut zip) = ZipArchiveFilesMap::from_fs(path)?;
        zip.set_comment(format!("Generated by {}", crate::APPNAME));
        Ok(Self::ZipArchive { file, zip })
      }
    }
  }

  pub fn open_file(&mut self, name: impl AsRef<Path>) -> Result<FileHandleDyn<'_>, FilesError> {
    match self {
      Self::Directory { root } => open_file(root.join(name)).map(file_to_file_handle),
      Self::ZipArchive { zip, .. } => zip.get_or_err_mut(name).map(buf_to_file_handle)
    }
  }

  pub fn open_file_maybe_not_found(&mut self, name: impl AsRef<Path>) -> Result<Option<FileHandleDyn<'_>>, FilesError> {
    match self {
      Self::Directory { root } => open_file_maybe_not_found(root.join(name)).map(|o| o.map(file_to_file_handle)),
      Self::ZipArchive { zip, .. } => Ok(zip.get_mut(name).map(buf_to_file_handle))
    }
  }

  pub fn create_file(&mut self, name: impl AsRef<Path>) -> Result<FileHandleDyn<'_>, FilesError> {
    match self {
      Self::Directory { root } => create_file(root.join(name)).map(file_to_file_handle),
      Self::ZipArchive { zip, .. } => Ok(buf_to_file_handle(zip.get_or_insert_new(name.as_ref())))
    }
  }

  pub fn create_file_new(&mut self, name: impl AsRef<Path>) -> Result<FileHandleDyn<'_>, FilesError> {
    match self {
      Self::Directory { root } => create_file_new(root.join(name)).map(file_to_file_handle),
      Self::ZipArchive { zip, .. } => zip.insert_or_err(name, Vec::new()).map(buf_to_file_handle)
    }
  }

  pub fn create_file_new_maybe_already_exists(&mut self, name: impl AsRef<Path>) -> Result<Option<FileHandleDyn<'_>>, FilesError> {
    match self {
      Self::Directory { root } => create_file_new_maybe_already_exists(root.join(name)).map(|o| o.map(file_to_file_handle)),
      Self::ZipArchive { zip, .. } => Ok(zip.insert(name, Vec::new()).map(buf_to_file_handle))
    }
  }

  pub fn dispose(self) -> Result<(), FilesError> {
    match self {
      Self::Directory { .. } => Ok(()),
      Self::ZipArchive { file, zip } => {
        zip.to_writer(file)
      }
    }
  }
}

#[inline]
fn file_to_file_handle(file: File) -> FileHandleDyn<'static> {
  Box::new(file) as Box<dyn FileHandle>
}

#[inline]
fn buf_to_file_handle(buf: &mut Vec<u8>) -> FileHandleDyn<'_> {
  Box::new(io::Cursor::new(buf)) as Box<dyn FileHandle>
}



#[derive(Debug, Clone)]
pub struct FilesMap {
  map: AHashMap<UniCase<PathBuf>, Vec<u8>>
}

impl FilesMap {
  pub fn new() -> Self {
    FilesMap { map: AHashMap::default() }
  }

  pub fn with_capacity(capacity: usize) -> Self {
    FilesMap { map: AHashMap::with_capacity(capacity) }
  }

  pub fn get(&self, name: impl AsRef<Path>) -> Option<&Vec<u8>> {
    self.map.get(UniCase::wrap_ref(name.as_ref()))
  }

  pub fn get_mut(&mut self, name: impl AsRef<Path>) -> Option<&mut Vec<u8>> {
    self.map.get_mut(UniCase::wrap_ref(name.as_ref()))
  }

  pub fn get_or_insert(&mut self, name: impl Into<PathBuf>) -> &mut Vec<u8> {
    self.map.entry(UniCase::wrap(name.into())).or_default()
  }

  pub fn get_or_insert_new(&mut self, name: impl Into<PathBuf>) -> &mut Vec<u8> {
    self.map.entry(UniCase::wrap(name.into())).and_modify(Vec::clear).or_default()
  }

  pub fn get_or_err(&self, name: impl AsRef<Path>) -> Result<&Vec<u8>, FilesError> {
    let name = name.as_ref();
    self.get(name).ok_or_else(|| {
      FilesError::FilesMapFileNotFound(name.to_owned())
    })
  }

  pub fn get_or_err_mut(&mut self, name: impl AsRef<Path>) -> Result<&mut Vec<u8>, FilesError> {
    let name = name.as_ref();
    self.get_mut(name).ok_or_else(|| {
      FilesError::FilesMapFileNotFound(name.to_owned())
    })
  }

  pub fn insert(&mut self, name: impl AsRef<Path>, buf: Vec<u8>) -> Option<&mut Vec<u8>> {
    use std::collections::hash_map::Entry;
    match self.map.entry(UniCase::wrap(name.as_ref().to_owned())) {
      Entry::Occupied(..) => None,
      Entry::Vacant(entry) => Some(entry.insert(buf))
    }
  }

  pub fn insert_or_err(&mut self, name: impl AsRef<Path>, buf: Vec<u8>) -> Result<&mut Vec<u8>, FilesError> {
    let name = name.as_ref();
    self.insert(name, buf).ok_or_else(|| {
      FilesError::FilesMapFileAlreadyExists(name.to_owned())
    })
  }

  pub fn remove(&mut self, name: impl AsRef<Path>) -> Option<Vec<u8>> {
    self.map.remove(UniCase::wrap_ref(name.as_ref()))
  }

  pub fn remove_or_err(&mut self, name: impl AsRef<Path>) -> Result<Vec<u8>, FilesError> {
    let name = name.as_ref();
    self.remove(name).ok_or_else(|| {
      FilesError::FilesMapFileNotFound(name.to_owned())
    })
  }

  pub fn clear_all(&mut self) {
    self.map.clear();
  }

  pub fn iter(&self) -> impl ExactSizeIterator<Item = (&Path, &Vec<u8>)> {
    self.map.iter().map(|(name, buf)| (name.as_ref(), buf))
  }

  pub fn iter_mut(&mut self) -> impl ExactSizeIterator<Item = (&Path, &mut Vec<u8>)> {
    self.map.iter_mut().map(|(name, buf)| (name.as_ref(), buf))
  }

  pub fn into_iter(self) -> impl ExactSizeIterator<Item = (PathBuf, Vec<u8>)> {
    self.map.into_iter().map(|(name, buf)| (UniCase::peel(name), buf))
  }
}



#[derive(Debug, Clone)]
pub struct ZipArchiveFilesMap {
  comment: String,
  map: FilesMap
}

impl ZipArchiveFilesMap {
  pub fn new() -> Self {
    ZipArchiveFilesMap { comment: String::new(), map: FilesMap::new() }
  }

  pub fn with_comment(comment: impl Into<String>) -> Self {
    ZipArchiveFilesMap { comment: comment.into(), map: FilesMap::new() }
  }

  pub fn with_capacity(capacity: usize) -> Self {
    ZipArchiveFilesMap { comment: String::new(), map: FilesMap::with_capacity(capacity) }
  }

  pub fn with_capacity_and_comment(capacity: usize, comment: impl Into<String>) -> Self {
    ZipArchiveFilesMap { comment: comment.into(), map: FilesMap::with_capacity(capacity) }
  }

  pub fn get_comment(&self) -> &String {
    &self.comment
  }

  pub fn get_comment_mut(&mut self) -> &mut String {
    &mut self.comment
  }

  pub fn set_comment(&mut self, comment: impl AsRef<str>) {
    comment.as_ref().clone_into(&mut self.comment);
  }

  pub fn clear_comment(&mut self) {
    self.comment.clear()
  }

  pub fn from_fs(path: impl Into<PathBuf>) -> Result<(File, Self), FilesError> {
    let path = path.into();
    match open_file_maybe_not_found(&path)? {
      Some(file) => {
        let zip_archive_files_map = ZipArchiveFilesMap::from_reader(&file)?;
        truncate_file(&file)?;
        Ok((file, zip_archive_files_map))
      },
      None => {
        let file = create_file_new(path)?;
        Ok((file, ZipArchiveFilesMap::new()))
      }
    }
  }

  pub fn from_reader(reader: impl Read + Seek) -> Result<Self, FilesError> {
    let mut zip_reader = ZipArchive::new(reader)
      .context("failed to open zip archive")?;
    let zip_file_comment = String::from_utf8_lossy(zip_reader.comment());
    let mut zip_archive_files_map = Self::with_capacity_and_comment(zip_reader.len(), zip_file_comment);

    for i in 0..zip_reader.len() {
      let mut zip_file = zip_reader.by_index(i)
        .context("failed to get zip archive file")?;
      if let Some(zip_file_name) = zip_file.enclosed_name().map(Path::to_owned) {
        let zip_file_buffer = zip_archive_files_map.get_or_insert_new(zip_file_name);
        io::copy(&mut zip_file, zip_file_buffer)
          .context("failed to read zip archive file")?;
      };
    };

    Ok(zip_archive_files_map)
  }

  pub fn to_fs(&self, path: impl Into<PathBuf>) -> Result<(), FilesError> {
    self.to_writer(create_file(path)?)
  }

  pub fn to_writer(&self, writer: impl Write + Seek) -> Result<(), FilesError> {
    let mut zip_writer = ZipWriter::new(writer);
    zip_writer.set_comment(self.comment.as_str());

    for (zip_file_name, zip_file_buffer) in self.map.iter() {
      let zip_file_name = AsRef::<Path>::as_ref(zip_file_name).to_string_lossy();
      zip_writer.start_file(zip_file_name, Default::default())
        .context("failed to start zip file")?;
      zip_writer.write_all(zip_file_buffer)
        .context("failed to write zip file contents")?;
    };

    zip_writer.finish()
      .context("failed to write zip archive")?;

    Ok(())
  }

  #[deprecated]
  pub fn edit<F>(mut source: File, callback: F) -> Result<(), Error>
  where F: FnOnce(&mut Self) -> Result<(), Error> {
    let mut zip_archive_files_map = Self::from_reader(&mut source)?;
    truncate_file(&source)?;
    callback(&mut zip_archive_files_map)?;
    zip_archive_files_map.to_writer(&mut source)?;
    Ok(())
  }
}

impl Deref for ZipArchiveFilesMap {
  type Target = FilesMap;

  fn deref(&self) -> &Self::Target {
    &self.map
  }
}

impl DerefMut for ZipArchiveFilesMap {
  fn deref_mut(&mut self) -> &mut Self::Target {
    &mut self.map
  }
}

#[deprecated]
pub fn create_or_edit_zip<F>(path: impl Into<PathBuf>, callback: F) -> Result<(), Error>
where F: FnOnce(&mut ZipArchiveFilesMap) -> Result<(), Error> {
  let path = path.into();
  let (file, mut zip_archive_files_map) = ZipArchiveFilesMap::from_fs(path)?;
  callback(&mut zip_archive_files_map)?;
  zip_archive_files_map.to_writer(file)?;
  Ok(())
}



pub fn truncate_file(mut file: &File) -> Result<(), FilesError> {
  file.seek(io::SeekFrom::Start(0)).context("failed to truncate file")?;
  file.set_len(0).context("failed to truncate file")?;
  Ok(())
}

pub fn open_file(path: impl Into<PathBuf>) -> Result<File, FilesError> {
  OpenOptions::new()
    .read(true).write(true)
    .open(path).context("failed to open file")
    .map_err(FilesError::from)
}

pub fn open_file_maybe_not_found(path: impl Into<PathBuf>) -> Result<Option<File>, FilesError> {
  FilesError::reject_io_err(open_file(path), io::ErrorKind::NotFound)
}

pub fn create_file(path: impl Into<PathBuf>) -> Result<File, FilesError> {
  OpenOptions::new()
    .read(true).write(true)
    .create(true).truncate(true)
    .open(path).context("failed to create file")
    .map_err(FilesError::from)
}

pub fn create_file_new(path: impl Into<PathBuf>) -> Result<File, FilesError> {
  OpenOptions::new()
    .read(true).write(true)
    .create_new(true)
    .open(path).context("failed to create new file")
    .map_err(FilesError::from)
}

pub fn create_file_new_maybe_already_exists(path: impl Into<PathBuf>) -> Result<Option<File>, FilesError> {
  FilesError::reject_io_err(create_file_new(path), io::ErrorKind::AlreadyExists)
}

pub fn canonicalize(path: impl AsRef<Path>) -> Result<PathBuf, FilesError> {
  let path = fs_err::canonicalize(path).context("failed to canonicalize path")?;

  #[cfg(windows)]
  let path = dunce::simplified(&path).to_owned();

  Ok(path)
}
